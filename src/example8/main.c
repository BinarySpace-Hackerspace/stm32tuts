#include "stm32l1xx_conf.h"

#include "nokialcd.h"
#include "main.h"

static volatile uint32_t TimingDelay;
void TimingDelay_Decrement(void);
 
void delayms(uint32_t nTime);

// glyph editor: http://www.carlos-rodrigues.com/projects/pcd8544/
static uint8_t custom_glyph[] = {0xff, 0x81, 0xbd, 0x81, 0xff};

static uint8_t bender [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
0xFC, 0xFF, 0xDF, 0xAF, 0x55, 0x80, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00,
0x55, 0x00, 0x55, 0x00, 0x55, 0x80, 0xD5, 0x80, 0xD5, 0xE0, 0xF5, 0x60, 0x75, 0x70, 0x75, 0x60,
0x75, 0xE0, 0xD5, 0x80, 0xD5, 0x00, 0x55, 0x00, 0x55, 0x00, 0x57, 0x07, 0x5E, 0x3C, 0x70, 0xF0,
0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0x5F, 0xFF, 0xFF, 0xFF, 0xD7, 0xEE, 0xD5, 0xE8, 0xD5, 0xA0, 0xD5, 0x80,
0xD5, 0xC0, 0xF5, 0xE0, 0xBD, 0xF8, 0xDF, 0xEE, 0x7F, 0x3B, 0x3F, 0x0F, 0x0F, 0x06, 0x06, 0x06,
0x06, 0x06, 0x0C, 0x0C, 0x38, 0x38, 0xF1, 0xC1, 0xC3, 0x07, 0x07, 0x3C, 0x3D, 0xF8, 0xF5, 0xC0,
0x55, 0x00, 0x55, 0x00, 0x55, 0x03, 0x57, 0x1E, 0x7C, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0xC7, 0xFF, 0xFD, 0x7A,
0xDD, 0xFE, 0xFF, 0x77, 0x7F, 0x3C, 0x7E, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0x80, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0F, 0x8F, 0xC4, 0xE0, 0x7D, 0x3F, 0x1F, 0x00, 0x00, 0x00,
0x80, 0x80, 0xE1, 0xE7, 0x7F, 0x3E, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x01,
0x57, 0x0F, 0x5C, 0x78, 0x70, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE0, 0xF0, 0xBC, 0xDF, 0xEF,
0xF7, 0xFF, 0xFF, 0xFF, 0x47, 0x03, 0x01, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xE0, 0x00, 0x01,
0x07, 0x07, 0x0E, 0xCC, 0xCC, 0xFC, 0x7C, 0x3C, 0x1C, 0x0E, 0x07, 0x83, 0xC1, 0xE0, 0x70, 0x30,
0x78, 0x1C, 0x5C, 0x0F, 0x57, 0x03, 0xD5, 0xC0, 0xD5, 0xE0, 0x75, 0x30, 0x35, 0xB8, 0xDD, 0xF8,
0xFD, 0xF8, 0xFD, 0xB8, 0x35, 0x30, 0xF5, 0xC0, 0xD5, 0x03, 0x57, 0x0F, 0x5F, 0xBC, 0xF0, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF,
0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xF0, 0xF0, 0xE1,
0xF1, 0xF0, 0x78, 0xB8, 0x5E, 0x2E, 0x57, 0x81, 0xD1, 0xE8, 0xF4, 0xB8, 0xFC, 0xBE, 0x77, 0xA3,
0x55, 0x80, 0xD5, 0xC0, 0xF5, 0x78, 0x3D, 0xBE, 0xFF, 0xE6, 0xF3, 0xF9, 0x1D, 0x0D, 0x07, 0x07,
0x0F, 0xF9, 0xF9, 0xF0, 0xF0, 0xB8, 0x19, 0x1F, 0xC6, 0xCE, 0xFB, 0xFB, 0x7F, 0xE8, 0xF5, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x3B, 0x77, 0x7F, 0x7F, 0x6F, 0x7F, 0x7F,
0x7F, 0x3F, 0x3F, 0x3B, 0x1D, 0x1C, 0x1D, 0x1E, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F, 0x3F, 0x7D, 0xEE,
0xFF, 0xFE, 0xF7, 0xEA, 0x7F, 0x7F, 0x7F, 0x3F, 0x1F, 0x1E, 0x7F, 0xE3, 0xC1, 0xE0, 0xF1, 0x73,
0x1F, 0x1E, 0x9F, 0xFB, 0xF3, 0x60, 0x70, 0xFC, 0xDD, 0xEF, 0xD7, 0xE3, 0xD7, 0xE1, 0xD5, 0xF8,
0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
};


void lcdBender(void)
{
  for ( int i = 0; i < ( 84 * 48 ) / 8; i++)
  {
    lcdWrite(LCD_DATA, bender[i]);
  }
}

void EnableClock()
{

  // divide HCLK / 2
  RCC_HCLKConfig(RCC_SYSCLK_Div2);

  // enable HSI
  RCC_HSICmd(ENABLE);
  RCC_PLLCmd(DISABLE);
  // wait for HSI to get ready
  while (RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);

  // configure PLL - x4 /2 
  RCC_PLLConfig( RCC_PLLSource_HSI, RCC_PLLMul_8,  RCC_PLLDiv_4 );
  RCC_PLLCmd(ENABLE);

  while ( RCC_GetFlagStatus( RCC_FLAG_PLLRDY ) == RESET );

  // set hsi as clock
  //RCC_SYSCLKConfig(RCC_SYSCLKSource_HSI);

  // set pll as clock
  RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
}

int main(void)
{

  RCC_ClocksTypeDef RCC_Clocks;
  RCC_GetClocksFreq(&RCC_Clocks);

  SysTick_Config((RCC_Clocks.SYSCLK_Frequency / 2) / 1000); // Cannot exceed 16,777,215

  /* Set SysTick Preemption Priority, it's a system handler rather than a regular interrupt */
  NVIC_SetPriority(SysTick_IRQn, 0x04);

  lcdInit();
  lcdClear();
	lcdBender();
  //lcdXY( 1, 2 );
  //lcdStr( "BinarySpace");
  //lcdXY( 1, 3 );
  //lcdGlyph( custom_glyph ) ;
  while (1);

}
 
void delayms(uint32_t nTime)
{
  TimingDelay = nTime;
  while(TimingDelay != 0);
}
 
// Called from SysTick_Handler
 
void TimingDelay_Decrement(void)
{
  if (TimingDelay != 0x00){
    TimingDelay--;}
}
 
void SysTick_Handler(void)
{
    TimingDelay_Decrement();
}